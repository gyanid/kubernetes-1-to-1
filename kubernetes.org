#+Title: Learning Kubernetes
#+Date: <2018-09-22 Sat>
#+Author: Yogesh Agrawal
#+Email: yogeshiiith@gmail.com

* Introduction
  Here will be learning kubernetes.

* Concepts
  - Kubernetes improves the development, delivery and maintenance of
    distributed applications.

  - Basics: pods, labels, annotations, services and replicasets.

  - Advanced: Daemon sets, jobs, configMaps, Secrets.
 
  - Deployments: lifecycly of a complete application.

  - Storage.

  - Based on three principles: immutability, declarative
    configurationm and online self healing systems.

  - Immutability: Once an artifact is created in the system it does
    not change via user modifications.

  - There are no incremental changes.

  - Immutable container images are at the core of everything that we
    will build in Kubernetes.

  - Everything in kubernetes is a declarative configuration object
    that represents the desired state of the system. It is kubernete's
    job to ensure that the actual state of the world matches the
    desired state.

  - Imperative defines actions, declarative defines state.

  - When it receives a desired state config, it does not take actions
    to make the current state match the desired state. It continuously
    takes actions to ensure that the curent state matches the desired
    state.

  - Combining three variable growth rates into a single growth rate
    reduces statistical noise and produces a more reliable forecast of
    expected growth.

  - Efficiency can be measured by the ratio of the useful work
    performed by machine or process to the total amount of energy
    spent doing so.

  - A dockerfile can be used to automate the creation of a Docker
    container image.

  - While designing a docker file, order your layers from least likely
    to change to most likely to change in order to optimize the image
    size for pushing and pulling.

* Kubernets Components
  #+BEGIN_SRC bash
$ kubectl get componentstatuses
NAME                 STATUS    MESSAGE              ERROR
controller-manager   Healthy   ok                   
scheduler            Healthy   ok                   
etcd-0               Healthy   {"health": "true"}
  #+END_SRC
** controller-manager
   It is responsible for running various controllers that regulate
   behavior in the cluster: for example, ensuring that all of the
   replicas of a service are available and healthy.

** scheduler
   The scheduler is responsible for placing different pods onto
   different nodes in the cluster.

** etcd server
   It is the storage for the cluster where all of the API objects are
   stored.

* Kubernetes Nodes
   #+BEGIN_SRC bash
$ kubectl get nodes
NAME       STATUS    ROLES     AGE       VERSION
minikube   Ready     master    12d       v1.10.0
   #+END_SRC
 
   In Kubernetes nodes are separated into master nodes that containe
   containers like the API server, scheduler, etc., which manage the
   cluster, and worker nodes where your containers will
   run. Kubernetes won't generally schedule work onto master nodes to
   ensure that user workloads don't harm the overall operation of the
   cluster.

* Cluster Components
** Kubernetes Proxy
   The kubernetes proxy is responsible for routing network traffic to
   load-balanced services in the Kubernetes cluster. To do its job,
   the proxy must be present on every node in the cluster. Kubernetes
   has an API object named =DaemonSet=, which we will learn about
   later.
   #+BEGIN_SRC bash
$ kubectl get daemonSets --namespace=kube-system kube-proxy
NAME         DESIRED   CURRENT   READY     UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
kube-proxy   1         1         1         1            1           <none>          12d
   #+END_SRC

** Kubernetes DNS
   Kubernetes also runs a DNS server, which provides naming and
   discovery for the services that are defined in the cluster. This
   DNS server also runs as a replicated service on the
   cluster. Depending on the size of your cluster, you may see one or
   more DNS servers running in your cluster. The DNS service is run as
   a Kubernetes deployment, which manages these replicas:
   #+BEGIN_SRC bash
$ kubectl get deployments --namespace=kube-system kube-dns
NAME       DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
kube-dns   1         1         1            1           12d
   #+END_SRC

   There is also a Kuberenetes service that performs load-balancing
   for the DNS server:
   #+BEGIN_SRC bash
$ kubectl get services --namespace=kube-system kube-dns
NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE
kube-dns   ClusterIP   10.96.0.10   <none>        53/UDP,53/TCP   12d
   #+END_SRC

   This shows that the DNS service for the cluster has the address
   =10.96.0.10=. If we log into a container in the cluster, we will
   see that the this has been polpulated into the =/etc/resolv.conf=
   file for the container.

** Kubernetes UI
   The final kubernetes components is a GUI. The UI is run as a single
   replica, but it is still managed by a Kubernetes deployment for
   reliability and upgrades.

   We can use the kubectl proxy to acces this UI.
   #+BEGIN_SRC bash
   $ kubectl proxy
   #+END_SRC

* Kubectl commands
** Namespaces
   Kubernetes uses =namespaces= to organize objects in the cluster. We
   can think of each namespace as a folder that holds a set of
   objects. By default, the kubectl command-line tool interacts with
   the default namespace. We can pass =--namespace= flag to refer a
   particular namespace.

** Contexts
   If we want to change the default namespace more permanently, we can
   use a context. This gets recorded in a kubectl configuration file,
   usually located at =$HOME/.kube/config=. This configuration file
   also stores how to both find and authenticate to your cluster. For
   example, we can create context with a different default namespace
   for your kubectl commands using:

   #+BEGIN_SRC bash
   $ kubectl config set-context my-context --namespace=mystuff
   #+END_SRC

   This creates a new context, but it doesn't actually start using it
   yet. To use this newly created context, we can run:
   #+BEGIN_SRC bash
   $ kubectl config use-context my-context
   #+END_SRC

   Contexts can also be used to manage different clusters or different
   users for authenticating to those clusters using the =--users= or
   =--clusters= flags with the =set-context= command.

** Viewing objects
   #+BEGIN_SRC bash
   $ kubectl get pods my-pod -o yaml
   $ kubectl get pods my-pod -o jsonpath --template={.status.podIP}
   $ kubectl describe <resource-name> <obj-name>
   #+END_SRC

** Creating, updating and destroying
   #+BEGIN_SRC bash
   $ kubectl apply -f obj.yaml
   $ kubectl delete -f obj.yaml
   $ kubectl delete <resource-name> <obj-name>
   #+END_SRC

** Labelling and annotating objects
   #+BEGIN_SRC bash
   $ kubectl label pods bar color=red
   $ kubectl label pods bar color-
   $ kubectl annotate pods bar color=red
   #+END_SRC

** Debugging commands
   #+BEGIN_SRC bash
   $ kubectl logs <pod-name>
   $ kubectl logs <pod-name> -f
   $ kubectl exec -it <pod-name> -- bash
   $ kubectl cp <pod-name>:/path/to/remote/file /path/to/local/file
   #+END_SRC

* Pods
  A pod represents a collection of application containers and volumes
  running in the same execution environment. Pods, not containers, are
  the smallest deployable artifact in a kubernetes cluster. This means
  all of the containers in a Pod always land on the same machine.

  Each container within a Pod runs in its own cgroup, but they share a
  number of Linux namespaces.

  Applications running in the same Pod share the same IP address and
  port space (network namespace), have the same hostname (UTS
  namespace), and can communicate using native interprocess
  communication channels over System V IPC or POSIX message queues
  (IPC namespace). However, applications in different Pods are
  isolated from each other; they have different IP addresses,
  different hostnames, and more. Containers in different Pods running
  on the same node might as well be on different servers.

** Thinking with Pods
   In general, the right question to ask yourself when designing Pods
   is, "Will these containers work correctly if they land on different
   machines? If the answer is "no", a Pod is the correct grouping for
   the containers. If the answer is "yes", multiple Pods is probably
   the correct solution.

* Command cheatsheet
  #+BEGIN_SRC bash
  $ kubectl get componentstatuses
  $ kubectl get nodes
  $ kubectl describe nodes node-1
  $ kubectl get daemonSets --namespace=kube-system kube-proxy
  $ kubectl get pods --namespace=kube-system
  $ kubectl get deployments --namespace=kube-system kube-dns
  $ kubectl get services --namespace=kube-system kube-dns
  $ kubectl get deployments --namespace=kube-system kubernetes-dashboard
  $ kubectl get services --namespace=kube-system
  $ kubectl proxy
  $ kubectl get pods --no-headers
  $ kubectl get pods -o yaml
  $ kubecetl describe pods <my-pod>
  $ kubectl label pods <pod> color=red
  $ kubectl label pods <pod> label-
  $ kubectl logs <pod-name>
  $ kubectl logs <pod-name> -f
  $ kubectl exec -it <pod-name> -- bash
  $ kubectl cp <pod-name>:/path/to/remote/file /path/to/local/file
  $ kubectl help
  $ kubectl help command-name
  #+END_SRC

  #+BEGIN_SRC bash
  $ kubectl config current-context
  $ kubectl config use-context mas-qa/oshift-api-jfk3-qa-bamtech-co:8443/yagrawal
  $ kubectl config view
  $ kubectl -n razcp-dev get deployment razcp-hello-world-app-chart -o yaml
  $ kubectl get componentstatuses
  #+END_SRC

* References
  1. Kubernetes Up & Running book.
